pacote Simulink:
atualizar firmware do drone
instalar RDNIS (Remote something)
bluetooth CSR
passar o modelo simulink para o drone
configurar firewall para habilitar conexão no ip local 192.168.3.2 (Mambo)
configurar firewall para o matlab (permitir conexoes)
teste realizado: ativa 2 helices opostas, depois outras 2 opostas,... com potencia definida.
como conectar: Painel de Controle\Hardware e Sons\Dispositivos e Impressoras
>> asbQuadcopterStart
--------------------------------------------
24/10:

pyparrot: apenas para linux, talvez testar posteriormente
node.js: linux/Mac OS? (26/10 resposta: tbm tem pra windows)
Gobot: Linux

----------------------------------------------
26/10

"resolvido" problema com bluetooth, instalado BlueSoleil, bluetooth nao aparenta estar tendo uma boa conexão
update 9 no matlab para conseguir rodar o teste no drone
teste realizado, oscilações após estabilizar a altura, descida brusca (nao obedeceu o sinal construido?)
node.js: a biblioteca BLE Noble tambem existe para windows. Reinstalar firmware de fabrica e testar esta abordagem (links atualizados em link.txt).
testar drone Mambo FPV via wifi

------------------------------------------------
01/11

dependencias: noble e node>6. dep do noble: node-gyp (dentro do windows-build-tools). dep do wind-build: npm
(instalando o npm aparentemente ta instalando tudo até o node-gyp, assim só vai faltar o noble)

------------------------------------------------
09/11

nao consigo instalar o modulo parrot-minidrone (npm install parrot-minidrone), e tambem outros modulos de controlar parrot com node.js, pois
"Refusing to install package with name "parrot-minidrone" under a package also called "parrot-minidrone"".
utilizando (npm install package.json) instala varios pacotes, porem não instala o parrot-minidrone
resolvido problema do pacote com msm nome, porem outros erros ainda continuam:
gyp ERR! build error
gyp ERR! stack Error: `C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\MSBuild\15.0\Bin\MSBuild.exe` failed with exit code: 1

pedir pro Pedro tentar instalar no Linux dele.
pedir pro Pedro criar conta pra mim no servidor
----------------------------------------------------
30/11

node.js: a biblio Noble só para sistemas 32 bits.
pyparrot: esperando conexao com o servidor, para instalar lá.
pyparrot funfou no windows. baixado o Anaconda, que possui python 3.7 (cuidado, pois ja tenho o 2.7 instalado, que nao serve).
criar arquivo de código .py e executar no ambiente python (abrir Anaconda e entrar no python: >> python, executar com >>> python teste.py)
voo funcionou, arquivo moving.py

------------------------------------------------------
07/12

endereço = "90:3a:e6:21:5e:20"
correção de como iniciar o programa: (abrir Anaconda, entrar no prompt e digitar >> python codigo.py) (precisa estar no diretório correto)
testado código demo de flip (flips.py)
testado movimento composto row+yaw (movimento circular) (moving2.py) (testar mais vezes, movimento nao foi como esperado)
groundcam.py nao funfou pois nao instalei o package cv2 ainda

sensores: 'sensores.py', 'lista de sensores.txt'
teste de sensores feitos: bateria, altitude, velocidades xyz;
teste de sensores a fazer: angulos de euller, posição xyz (ambos feitos)

----------------------------------------------------------
14/01

posição: aparentemente é calculada utilizando as informações de velocidade e angulos de euller
GUI: apenas um visualizador da camera FPV utilizando VLC.
tentando adicionar os valores de posição aos sensores lidos: foi removido do sensors_dict, porem ainda nao consigo lê-los.

----------------------------------------------------------
15/01

consegui ler as posições fora do sensors_dict: os codigos precisam estar na mesma pasta da "biblioteca" minidrone.py
a leitura de angulos de euller, como é convertida do quaternium, nao funciona com as helices desligadas
identicamente, a leitura de posição, como é (possivelmente) calculada dos dados de velocidade e angulos de euller, também nao funciona para helices desligadas
o calculo da altura posz talvez seja apenas pegar a altitude, e nao realmente calcular, pois foi visto em alguns testes que os valores coincidem.
fazer teste de moving_sensors.py: andar para frente ate chegar na posição 50 cm. colocar dentro do loop correções de roll
(movimento está tendendo para esquerda, talvez seja posição resultante após takeoff)

------------------------------------------------------
18/01

testes em moving_sensors.py, com movimento em X e correção de Y aplicando roll.
testes em moving_sensors.py, controlador proporcional nos erros X e Y, fazer mais testes e melhorar ganho.

----------------------------------------------------

22/01

feito um controlador para erro e velocidade, falta testar (moving_sensors.py)
teste de pitch-pwm: aplicar pitch 1 e pitch 0 com diferentes intervalos de tempo, para tambem verificar tempo de resposta do drone. (moving.py)
pitch 1 duration 3: pos_final = 31 a 34, speed = 0.11 - 0.14
pwm: duration 0.1 sleep 0.1: foi pro lado esquerdo e nao pra frente
pwm: duration 0.2 sleep 0.1: pos_final = 12 - 21, speed = 0.10 (provavelmente yaw diferente do teste anterior)
while pos<40 e duration none (sem sleep): foi pra esquerda e deu ruim na hora de abortar

------------------------------------------------------
23/01

retomar testes basicos para verificar bias de roll (tudo 0, pitch 1, roll 1, ambos -1)
bias de roll: aparentemente movimento tende para esquerda, movimento exato (sem erro em y) com roll aprox = 2 (tilt default)
diferentes movimentos nao esperados em varios testes, ajustar max_tilt pra ver se melhora
max tilt em 30, teste com roll=20 e -20, deu certo, um pouco rapido
max tilt 30, teste com roll e pitch = 5 e -5 separadamente, ok
teste com ambos juntos, deu bom, mas percebe-se o bias de roll (com 5 vai lento pra direita, com -5 vai rapido pra esquerda)
testes em moving_sensors.py: caso esteja indo na direçao errada, aumentar força do pitch/roll. movimento tendendo para frente.
provavelmente fazer movimentos desacoplados (primeiro em x dps em y) seria melhor. implementando isso em moving_dec.py (dec = decoupled)
moving.py: determinar melhor max_tilt e valor de roll para encontrar o bias.
tilt 10 e roll 5 (ou seja, 0.5 graus), ele foi bem pouco para esquerda, 6 ja vai pra direita
possibilidades de movimento desacoplado: pitch para x, roll para y; pitch para x, yaw+pitch para y.
utilizando tilt 10. pitch positivo foi para frente sem erro em y, porem pitch negativo fez drone ir para esquerda e nao para tras (pode ser valor mto baixo)
alterando moving_sensors: alterei tilt para 10, mudei o yaw e falta mudar o resto

-------------------------------------------------------
24/01

moving_dec.py: velocidade maxima agora em função do erro: menor erro = menor vel max
teste basico (vel_pitch.py): descobrir relação velocidade por pitch
com pitch 5 (tilt 10), movimento tendeu para esquerda, abortado
com pitch 10 e yaw tendendo para direita, movimento foi reto, velx = 0.37 - 0.44, vely = 0.05 - 0.12, posx/y = 294/-18, posfinalx/y = 356/-32, pos final real = 550 cm
tamanho bateria 550mah medido: 4.4cm x 2.6cm x 0.9cm
camera updated, o log dela sera feito no arquivo camera.txt

--------------------------------------------------------
30/01

testes com o segundo drone: mamboAddr = "D0:3A:BD:55:E6:23"
takeoff indo muito para direita, precisa ter espaço para nao bater, depois volta um pouco mas nao chega ao local XY de partida
movimento com pitch 5 tilt 10: aparentemente tendendo pra direita
teste de giro com turn_degrees(90): muito bom

XXXXXXXXXXXXXXXXXXXXX  TESTAR TROCAR AS HELICES ENTRE OS DRONES, OBSERVAR COMPORTAMENTO: feito, o comportamento nao mudou, como era esperado

voltando a testes com primeiro drone:
correçao de yaw: yaw 2 tilt 10, duration 0.2 sleep 0.3
pitch 5 tilt 10: movimento tende para esquerda. velocidade 0.2, XY = 54/-34
pitch 5 tilt 10: movimento reto (yaw visualmente negativo - esquerda). velocidade 0.06, XY = 17/-3
correçao de yaw: yaw 2 tilt 10, duration 0.2 sleep 0.8
pitch 5 tilt 10: movimento reto (sem correçao yaw). velocidade 0.07, XY = 18/-5
teste de flat_trim(): nao pareceu mudar muita coisa, observar melhor
pitch 5 tilt 10: movimento p direita (com correçao yaw). velocidade 0.08, XY = 25/7, yaw apos correçao/antes do voo/dps do voo = 0,57/1,44/2,47
quaternium nao eh oq eu achava. dar uma estudada e procurar artigos de controle de drones

-----------------------------------------------------
31/01

pitch pequeno (abaixo de 5 com tilt 10) faz drone ir para esquerda e nao para frente
pitch 10 roll 2: yaw=0.2, spd = 0.12, XY = 40/-13
pitch 5 roll 3: foi um pouco pra direita e voltou: yaw=-0,73, spd = 0.11, XY = 32/0.5
pitch 5 roll 3: yaw=-1,38, spd = 0.05, XY = 18/-14
pitch 5 roll 3: yaw=-0,82, spd = 0.06, XY = 18/-4
(segundo drone) pitch 5 roll 3: pouco trás muito direita
(segundo drone) pitch 10 roll 0: frente direita
(segundo drone) pitch 5 roll -2: direita
pitch 0 qnd velocidade alta: o comando de pitch 5 (ou 8), roll 3 (ou 0), dps de parar uma vez, começa a ir pra esquerda e nao pra frente
talvez começar a usar pitch 10 e roll 10 (com tilt 10: angulo minimo de 1 grau) ajude

----------------------------------------------------
01/02

testes com camera: feita a aquirição de video das 3 cameras (webcam, axis, teto), feito tutorial de aumento de FPS usando threading (cam_fps.py)
diferenciação (aquisição) de diferentes cores na imagem (cam_color.py)
aquisição do contorno e suas propriedades (cam_contour.py), alem de outros features como menor retangulo a enquadrar a figura
aquisição do contorno e suas propriedades em um video (cam_cont2.py), calculo do centroide do segundo maior contorno - o primeiro eh a borda da tela dependendo do caso)

---------------------------------------------------
05/02

drone 2 atualizado firmware. voo manual com app via BT: takeoff ainda ruim (indo pra direita), movimento de pitch ok, sem tender pra nenhum lado.
voo manual BT com primeiro drone: takeoff normal, pitch normal (sem tender para nenhum lado)
pitch 10 dur 0.3 sleep 0.2 speed alto = pitch 0 + sleep: drone2 tende direita, drone1 tende esquerda
pitch 10 dur 0.3 sleep 0.2 speed alto = sleep: mesmo efeito, ele tenta parar o movimento
subfunções para correção de yaw e ajuste do roll por causa do bias
testes em moving.py para correçao de bias foram bons, testando agr moving_dec.py

--------------------------------------------------
06/02

troca de helices entre os drones: o comportamento nao mudou (a mudança das helices nao alterou comportamento)
retestando moving.py para ajustar melhor a funçao bias_roll para drone 1.
alternando o bias_roll entre considerar posiçao, velocidade ou ambos, e mudando valores. as infos de velocidade parecem estar ruins
testando moving_dec.py: indo bem, considerando que a leitura de sensores do drone nao está muito boa

-----------------------------------------------------
08/02

camera: cam_final.py: calcula angulo do drone pela identificação das cores vermelho e azul, a partir do centroide do contorno de cada cor

-----------------------------------------------------
13/02

cameras dao travadas de vez em quando
fps medio (com travadas) usando as duas cameras e contando apenas quando ambas foram atualizadas: 7
fps medio (com travadas) usando uma camera, apenas quando ela é atualizada (nao conta frames repetidos): 11
cam_final (calculo do angulo) not working.
cameras possuem area muito pequena de intersecção, possivel mudar angulo das mesmas, porem perder parte da visao do tablado

---------------------------------------------------
15/02

cameras com "uma seta" de inclinação para dentro do tablado: altura da intersecçao = 60cm, comprimento = 37cm (perda de 20cm do tablado de um lado e 13cm do outro)
pelo menos uma das cameras sempre identificará o drone, caso ele voe abaixo da altura da intersecçao (nao voará por pontos cegos)
cam_final (calculo do angulo) working, com amarelo e azul. seria bom utilizar media de algumas leituras, pois está ruidoso.
correção da camera 2 (Perspective Transformation), pontos de interesse: 34 16 , 596 16 , 578 479 , 66 479
correção da camera 1 (Perspective Transformation), pontos de interesse: 34 16 , 558 16 , 575 479 , 23 479  
fazer mapeamento pixel - distancia (cm)
####################  como o drone está a uma certa altura do tablado, recalcular dimensoes do plano onde ele se encontra? falar com Genos (FEITO)

---------------------------------------------------
18/02

calculo da posição sem e com correçao devido a altura (cam_pos.py), feitos varios testes na cam1 (diferentes posiçoes e alturas), todos deram certo com erro max de 1cm (img4 e img5)
novos pontos de interesse: 	pts1 = np.float32([[24,16],[576,16],[574,479],[35,479]]) #cam1
	pts2 = np.float32([[34,16],[598,16],[581,479],[66,479]]) #cam2

------------------------------------------------------
21/02

incluida a cam2 em cam_pos.py, feita a transição de cameras (se cam1 nao pega, procurar em cam2), ajustando cam1 e cam2 para incluir bordas fora da mesa que foram cortadas.
procurar por detecçao de objetos e remoçao de background como tecnicas para localizaçao
inves de usar tag com 2 cores, colar "papeloes" no centro ou bordas do drone, utilizando cores nos mesmos e assim aumentar precisao da localizaçao

------------------------------------------------------------
22/02

a fazer: remoçao de ruidos dos frames (filtro) e calculo da altura por tamanho da tag (ver calib do matlab)

-----------------------------------------------------------
26/02

testes de altitude com drone: manutenção na altura 0.7 é boa (flutuação de max 1cm),
na altura 0.5 já há maiores flutuações (até 5cm para baixo)
aparentemente a leitura possui erros bem pequenos (devidos também à propria flutuação do drone)
alguns testes apresentam diferenças grandes de leitura e real posição
##### TESTAR FLUTUAÇOES EM ALTURAS MENORES
##### TESTAR O QUE ACONTECE COM MOVIMENTO PITCH OU ROLL CASO PASSE POR CIMA DE OBSTACULO

------------------------------------------------------------
27/02

passar algo embaixo do drone enquanto o mesmo está em "flat_trim" faz ele aumentar sua altitude, porem a leitura
do sensor continua a mesma (o drone sobe mas "nao sabe disso")
testes no tablado (com arcon), flutuação em torno de 0.5:
altura inicial 0.799, trim entre 0.464 - 0.501 (3.7 cm)
altura inicial 0.798, trim entre 0.477 - 0.508 (3.1 cm)
testes no tablado (com arcon), flutuação em torno de 0.726:
altura inicial 0.795, trim entre 0.703 - 0.705 (0.2 cm)
altura inicial 0.804, trim entre 0.703 - 0.716 (1.3 cm)
altura inicial 0.809, trim entre 0.693 - 0.711 (1.8 cm)
testes no corredor, movendo com pitch e dps verificando flutuaçao na altura:
altura apos mov 0.707, trim entre 0.707 - 0.756 (4.9 cm), na verdade o drone estava mais alto (~80cm)
altura apos mov 0.731, trim entre 0.702 - 0.747 (4.5 cm), ficou muito proximo aos cones, teste "invalido"
corredor, movendo c/ pitch, verificando o que acontece ao passar por cima de obstaculos: sem alteração na altura

----------------------------------------------------------
28/02

confirmado problemas de leitura no sensor de altitude, enviada mensagem para Amy.
Vai ter que usar a terceira camera para calcular altura provavelmente.

---------------------------------------------------------
01/03

testar varios subir descer, ir frente tras, varios subir descer denovo, para ver erro do sonar
teste1: apos movimentos horizontais, houve erro, que se manteve durante as subidas/descidas (como esperado)
começar a calcular altura do drone com terceira camera
testar se mudar o flying state do drone arruma a leitura do sonar
landed, takingoff, hovering, flying, landing, emergency, rolling, init. 

----------------------------------------------------------
06/03

testado mudar state do drone entre hovering e flying. leitura do sonar nao mudou
state do drone nao muda sozinho para flying quando faz vertical movement (checar horizontal)

----------------------------------------------------------
07/03

testando pegar altura pela terceira camera. (alteraçoes em cam1 e cam2 para pegar o azul apenas em ROI proxima do amarelo - nao deu certo)
problema: cam1/2 depende da altura gerada por cam3, cam3 depende do Y gerado por cam1/2. - tendo um valor inicial, ambos se corrigem/convergem)
reajustando posição das cams 1 e 2

-------------------------------------------------------------
14/03

testado cam3: erro de 3 cm

-------------------------------------------------------------
15/03

novas helices nao estao entrando no drone, o buraquinho é menor que a haste dos motores.
cam_pos2.py funcionando, altura Z calculada bem, com erro prox de 1cm
usar algum marcador(es) no tablado para calcular automaticamente os pontos de interesse, para evitar
recalcular manualmente toda vez.
pesquisar sobre aplicação de filtro nos frames.
testar comunicar com drone por BT e usar/testar garra, procurar sobre os sinais enviados nos 4 pinos de ligaçao

-------------------------------------------------------------