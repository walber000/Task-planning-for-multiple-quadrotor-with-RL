--------------------------------------------------------------------------------------------
19/07

oscilaçao de leitura da propria camera: ~0.3cm nos 3 eixos
esfera de oscilaçao em hover: (hover por 20s)
(com espuma em baixo, ang -90)
X: 5,22 Y: 2,72 Z: 3,47
X: 5,72 Y: 2,53 Z: 7,99
X: 6,05 Y: 3,51 Z: 2,87
X: 6,44 Y: 3,84 Z: 4,36
X: 5,53 Y: 3,57 Z: 3,11
X: 5,37 Y: 3,01 Z: 2,35
X: 4,26 Y: 1,62 Z: 1,60
X: 3,28 Y: 3,12 Z: 6,14
(sem espuma ang-90:)
X: 5,58 (-0,03/+5,54) Y: 4,66 (-4,65/+0) Z: 6,96 (-0/+6,96)
X: 4,83 (-0/+4,83) Y: 3,39 (-1,32/+2,08) Z: 1,86 (-1,83/+0,02)
X: 3,21 (-1,19/+2,02) Y: 4,44 (-2,30/+2,15) Z: 4,47 (-0,93/+3,54)
X: 6,32 (-0,10/+6,22) Y: 1,94 (-1,17/+0,76) Z: 1,92 (-0,25/+1,67)
(com espuma ang -180:)
X: 3,08 Y: 6,72 Z: 4,53
X: 2,59 Y: 4,09 Z: 5,19
(sem espuma ang-180:)
X: 2,76 Y: 6,22 Z: 3,44
X: 2,82 Y: 2,88 Z: 4,64
X: 3,88 (-1,12/+2,76) Y: 5,50 (-1,4/+4,1) Z: 5,52 (-1,63/+


max: X 6,44  Y 4,66  Z 7,99
------------------------------------------------------------------------------------
22/07

adicionado peso à helice frente-esquerda: movimento tendeu para este lado, porem nao afetou muito a estabilização
adicionado segundo peso, à helice frente-direita: drone ficou pesado e nao consegue manter voo, cai e desliga.
apenas peso da helice frente-direita: tambem ficou pesado e nao manteve voo

conseguiu pegar novo objeto (pouco menor e com argola mais alta), leve dificuldade nos movimentos.
>>> criar objeto mais estavel e pega-lo na maioria dos testes
>>> pensar em estrategia de controle de movimentos mais eficaz (controle + dinamica do drone)
>>> testar multidrone basico

-------------------------------------------------------------------------------------
23/07

objeto menor com arame maior: nao conseguiu se manter em uma altura, muita oscilação no eixo Z (drone_obj.py)
objeto maior com arame menor: teve uma boa estabilização, conseguiu realizar movimentos sem mta oscilação (drone_obj2.py)
>>> testar firmware do simulink
>>> fazer plot3d do teste de hovering, calculando tbm erro a partir do ponto inicial

--------------------------------------------------------------------------------------
24/07

feito plot3d.py (ros), plota posição do drone em plot3d, falta juntar com teste de hovering.

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
16/08

plot3d plota pontos (scatter) em vermelho, nao usa mais funcAnimation, axis proximo ao ponto inicial do drone.
arcon ligado, hover 10s, ang -90, espuma:
dx: 6.19 ( -0.98 + 5.21 ) dy: 4.74 ( -4.74 + 0.00 ) dz: 2.70 ( -0.84 + 1.86 )
dx: 3.52 ( -0.10 + 3.42 ) dy: 4.74 ( -2.24 + 2.50 ) dz: 5.40 ( -4.46 + 0.93 )
dx: 7.10 ( -0.77 + 6.33 ) dy: 4.90 ( -0.00 + 4.90 ) dz: 4.80 ( -1.89 + 2.91 )
dx: 5.45 ( -0.19 + 5.27 ) dy: 5.23 ( -1.59 + 3.64 ) dz: 1.72 ( -1.40 + 0.32 )

piores casos:
dx: 7.10 ( -0.98 + 6.33)
dy: 5.23 ( -4.74 + 4.90)
dz: 5.40 ( -4,46 + 2,91)

lendo sobre Docker, para instalar o Sphinx em um container no Olympus

>>> testar firmware do simulink
>>> simulação (Sphinx)
>>> criar objeto mais estavel e pega-lo na maioria dos testes
>>> pensar em estrategia de controle de movimentos mais eficaz (controle + dinamica do drone)
>>> testar multidrone basico
----------------------------------------------------------------------------------------
21/08

plot3d salva os pontos da imagem, plot3dread le arquivo e plota a imagem.

----------------------------------------------------------------------------------------
22/08

-> simulação em matlab
-> simulação em xplane
-> simulação em sphinx
-> simulação pronta em simulink

Instalando sphinx em docker no olympus
---------------------------------------------------------------------------------------
23/08

Sergio:
-> Simulação em x-plane: controlador do drone
-> Simulação em Matlab: montagem de estrutura

--------------------------------------------------------------------------------------
26/08

problema de "connection failed IP=[...]" em apt-get install pode ser pela rede do ITA
Existem muitas dificuldades em implementar o sphinx em docker, por causa do systemd.
lendo tese do sergio sobre a simulação feita no matlab

--------------------------------------------------------------------------------------
27/08

calibração do controle -> RL, x-plane
plano de construçao: sequencia de montagem (ordem de instalaçao dos elementos da estrutura) e manobras -> RL
planejamento de trajetoria -> A*
evitar colisão -> RL

-> simulação: verificar planejamento de trajetoria com A* para 1/2 drones

pos-meeting:
-> LA gera sequencia de peças a ser pegada, A* gera trajetorias
>> entender o LA, terminar o A*, ampliar para varias trajetorias/goals.

----------------------------------------------------------------------------------
02/09

terminado o A* em Matlab.
>> entender LA
>> expandir A* para varios goals (not now)

LA aplicado no meu trabalho:
-> conjunto de açoes de carga e descarga, similar ao trab do Sergio,
onde dentro do conjunto de açoes de carga, existiria uma açao de carga para cada
peça, cada açao com sua probabilidade.
O treinamento se faria com o drone capturando as peças na ordem estabelecida pela
escolha de açoes do LA, e a função custo calcularia o tempo total gasto por essas ações.
Após o treinamento, as probab das ações criariam uma rota de voo que possui tempo "ótimo".

ex:
Num_objetos = 5
Açoes_carga = [carga(1), carga(2), carga(3), carga(4), carga(5)]
Açoes_descarga = [descarga(1), descarga(2), descarga(3), descarga(4), descarga(5)]
P_carga(k) = [0.2 0.2 0.2 0.2 0.2], para qualquer instante k

se a melhor ordem fosse 1 -> 3 -> 5 -> 2 -> 4:

k = 1: P_carga(k=1) = [1 0 0 0 0]
k = 2: descarga(1)
probab de carga(1) forçada para zero, pois ação nao pode mais ser tomada

k = 3: P_carga(k=3) = [0 0 1 0 0]
k = 4: descarga(3)

k = 5: P_carga(k=5) = [0 0 0 0 1]
k = 6: descarga(5)

k = 7: P_carga(k=7) = [0 1 0 0 0]
k = 8: descarga(2)

k = 9: P_carga(k=9) = [0 0 0 1 0]
k = 10: descarga(4)


pos-meeting:
>> ajustar o A* para considerar distancia vertical diferente da distancia horizontal
(isso afetará tambem os angulos e translaçoes, nao serao mais 45graus e raiz2 distancia)
>> estudar o codigo de LA do professor e fazer o meu baseado na aplicaçao construida acima.
>> entender métrica de custo do Sergio, se realmente foi tempo de voo total
>> entender quais as ações no trab do sergio, se são simplesmente carga em certa peça.

-------------------------------------------------------------------------------------
03/09

(x) ajustar o A* para considerar distancia vertical diferente da distancia horizontal

-------------------------------------------------------------------------------------
04/09

entendendo LA do Cairo (rl_lab.m)
>> bootstrap learning: entender/aprender
livros: Narendra (LA), Sutton (RL), Sastry (FALA)

------------------------------------------------------------------------------------
05/09

criando Astar.m a partir de romeoPlus.m, para ser chamado em LA_trajetoria.m
funcionará como um calculo de distancia, porem considerando obstaculos e movimentos em grid.
feito plotMap.m para plotar o mapa do labirinto (Astar.m plota apenas as linhas do movimento)

--------------------------------------------------------------------------------------
06/09

fazendo LA_trajetoria.m
>> passar doc do sergio pro Word e mandar pra ele
>> livro: Sastry

--------------------------------------------------------------
09/09

(x) passar doc do sergio pro Word e mandar no grupo
terminado LA_trajetoria (caso 1)
(x) Examinar as outras restriçoes para o caso 1
testar neta menor para melhorar resposta encontrada (porem reduzir velocidade de convergencia)

-----------------------------------------------------------
10/09

LA_trajetoria.m alterado para considerar convergencia quando prob>0.95, e nao apenas num.max de iteraçoes
testando caso1, neta=0.2, NStepMax=10, 5 objetos, prob_conv = 0.9: conv em iter 64-197
alterado NStepMax = 20: Convergencia demorou mto mais (127-474), porem conseguiu sair de 90% no mov3 (nao era o max global) para 90% no mov1 (global)

criando LA_trajetoria2.m para considerar caso 1.1) drone captura multiplos objetos por voo

corrigido erro no A-estrela onde o vetor h estava definido como matriz

terminado LA_trajetoria2.m
-------------------------------------------------------------
11/09

criado LA_trajetoria3.m, para caso 1.2)

>> testar learning separado para cada açao
>> caso1.2: se o primeiro (ou qualquer mov antes do ultimo) movimento ja nao segue a ordem de peça, dar logo break na iteraçao, ou esperar ela acabar?
>> considerar peso 0.1 para rotaçao ao inves de 0, pois assim prioriza-se curvas suaves (numa curva acentuada, o drone teria que diminuir velocidade, oq é um custo de tempo)

--------------------------------------------------------------
12/09

terminado LA_trajetoria3.m (caso 1.2)
começado caso 2 em LA_trajetoria4.m
(x) se peça3 capturada, deixada em local 2 (errado), diminuir prob dos dois?
----------------------------------------------------------
13/09

trabalhando em LA_trajetoria4.m
alteraçoes em traj3 e traj4.m para se tratar corretamente a inclusao dos casos de erro
terminado LA_trajetoria4.m (caso 2, 2.1, 2.2)
>> nao faria sentido, ja que passou-se pelo minimo, salvá-lo e utilizá-lo?
(x) atualizar funçao de reforço que está ruim com o sign
>> learning separado para cada açao
(x) atualizar o word
plotando reforco, dist_hist, dist_min
corrigido erro no A* (tava usando mapa errado) e aumentada prob_conv para 0.975.
Agora converge no minimo, e geralmente eh global.

----------------------------------------------------------
16/09

alterando caso 1.1 (carga) para LA aprender se deve pegar mais de 1 objeto (LA_traj5.m)
falta fazer caso 2.1, quantidade de carga diferente, fazendo em LA_trajetoria6.m

------------------------------------------------------------
17/09

>> considerar xteta pequeno no A* para suavizar rota

terminado LA_traj5.m (caso 1.1 carga)
(x) arrumar LA_traj6.m (caso 2.1 carga)
(x) checar funcionamento do LA_traj4 e 5 (ok)
---------------------------------------------------------------
18/09

1- caso 1
2- caso 1.1 (old, nao aprende quantidade de carga)
3- caso 1.2 (inclui caso 1.1 old)
4- caso 2 e 2.2 (inclui caso 2.1 old mas nao funciona), corrigido reforço desta versao em diante
5- caso 1.1 new (aprende quantidade de carga) e 1.2
6- caso 2, 2.2 e 2.1 new

terminando LA_trajetoria6.m
------------------------------------------------------------
19/09

>> robo carregando 2 objetos, coloca eles em zona de descarga errada,
sabe-se qual dos dois foi o errado e aplica reforço negativo apenas nele?
ou nao se sabe e aplica nos dois?
LA_traj6.m considera que sabe-se qual foi o errado (variavel index)

>> reforço max (ajuste de prob para 0) quando objeto é recusado na zona?
(x) testando ajustar dist_min apenas depois do aprendizado (nao muda nada, pois ref será maximo em ambos os casos)
tentar correlacionar quantidade de carga com zonas de descarga aceitarem mais que 1obj (no)
(x) carregando 2 objs, escolher uma zona: probabilidade media dos dois objetos.

LA_traj6.m: restriçao de zona OK, restriçao de ordem OK, carga(até2) OK
zona + ordem OK, ordem + carga OK, zona + carga MAISOUMENOS
--------------------------------------------------------------
23/09

>> em LA_traj6, mudar relaçao cargaxtempo para outra coisa
>> fazer LA_traj7, onde ao pegar 2 cargas ou mais, pode deixa-las separadamente em zonas diferentes

Duvidas:
-> reforço max neg (ajuste de prob para 0) quando objeto é recusado na zona
-> robo carregando 2 objetos, coloca eles em zona de descarga errada,
sabe-se qual dos dois foi o errado e aplica reforço negativo apenas nele?
ou nao se sabe e aplica nos dois? ou em nenhum?
-> nao faria sentido, ja que passou-se pelo minimo, salvá-lo e utilizá-lo?
a não-convergencia para o minimo é normal ou problema no meu codigo?
-> relacionar matriz_prob de qtd carga com outra coisa sem ser o tempo? 
-----------------------------------------------------------------
24/09

fazendo rota.m, que pega resultado do LA_traj e calcula waypoints e distancia total final.

-----------------------------------------------------------------
25/09

rota.m mostra vetor de waypoints da trajetoria.
vendo simulaçao do simulink, como alterar valores de referencia.
testado simulaçao com referencia landingsearch, dando erro no final

------------------------------------------------------------------
30/09

utilizando ROS Matlab, criar serviço que chame LA_traj e rota.m para retornar WP's,
serviço será chamado pelo nó de comando do drone, em python
tentando achar serviço que tenha request e response do tipo array

-----------------------------------------------------------
01/10

para drone fazer movimento diagonal, fazer correçoes de mov's errados considerando
yaw do drone, ou passar referencia da camera para o drone (rotaçao de eixos)

------------------------------------------------------------
02/10

matlab publicar e olympus ouvir: ok
matlab ouvir e olympus publicar: precisa dar export ROS_IP=192.168.0.41 no Olympus, para
o matlab reconhecer o IP de quem ele deve ouvir.

------------------------------------------------------------
03/10

LA_ros.m invoca LA_traj6.m que recebe WP de rota.m e publica no ROS (topico /wp)
listener_wp.m (na pasta 'ros') recebe a leitura do publisher wp.
(x) está mandando wp quebrado em 2 vetores, mandar tudo em um vetor só e separar dps.

------------------------------------------------------------
04/10

passando wp como vetor e mudando para matriz no recebimento.

reuniao com Sergio:
> reforço max negativo em caso de zona errada: ok, mas usar apenas reforço grande
> carregar 2 peças e errar uma na zona de descarga: reforço 0, neg apenas se errar as 2
> tirar media das probs para escolher zona do caso acima: ok
>> plotar crescimento das probs por iteraçoes (pag121 Sergio: min, med e max das probs)
>> nao convergir para minimo achado: ok, mas ajustar parametros do LA (ver livro) para melhorar
>> usar formula de ajuste de prob que amortece crescimento da prob (LRI, pag15 Sastry)
>> multi-drone: passar codigos para velocidade-tempo e começar por sequencial
(segundo drone só atua qnd primeiro ja efetuou carga e descarga)

------------------------------------------------------
07/10

feito grid semelhante ao tablado (29x17, grid de 10cm -> 280x160 cm)
A* ficou bem mais lento

------------------------------------------------------
08/10

testando diferentes atualizaçoes e normalizaçoes (pag15 Sastry) p/ o LA
p/ metodo de atualizaçao da pag15 (LRI), usar apenas reforço positivo, senao probs podem ser zeradas

reuniao:
restrições interessantes que simulam problemas reais:
>> zonas de descarga possuem demandas (simula problema de construçao)
>> objetos possuem quantidade de material (transportador nao precisa pegar todo o 'objeto')

-------------------------------------------------------
09/10

plotMap.m desenha numero da zona dentro dela.
rota.m desenha quantidade de objetos na zona, e marca "X" em objetos já capturados.

-------------------------------------------------------
10/10

atualizaçao e normalizacao da pag15 sastry: converge rapido porem resultado pior
LA_traj7.m para fazer restriçao 2.4)
demanda = num_obj: ok
demanda > num_obj: ok
demanda < num_obj: ok
arrumando rota.m para imprimir caso de demanda < num_obj
-------------------------------------------------------
11/10

arrumado rota.m
criando LA_traj8.m, para restriçao 2.5)
>> integrar demanda com capacidade de carga? (se demanda = 3, tem 2 obj e coloca mais 2, reforço negativo?)
--------------------------------------------------------
14/10

para restriçao 2.5, relaçao feita em prob2 (zona x objeto) teria problema, pois toda a quantidade de material de um objeto
teria que ir para mesma zona.
Para solucionar, fazer prob2 considerar que existem multiplos objetos no mesmo lugar
terminando LA_traj8.m, criado rota2.m para imprimir resultado (pois prob2 é diferente dos anteriores)
(x) terminando rota2.m
-------------------------------------------------------
15/10

terminado LA_traj8.m e rota2.m
peso da garra: 8.365g
segunda garra: 8,392g
(x) fazer rota2.m deixar historico de movimentos feitos, em cor mais fraca e/ou tracejada
--------------------------------------------------------
16/10

rota2.m deixa rastro de movimentos anteriores inves de apagá-los.
drone_wp.py recebe /cam_topic e /wp, converte /wp em medidas reais (cm).

--------------------------------------------------------
17/10

alterando Astar.m e rota2.m para retornar waypoints nó a nó.

-------------------------------------------------------
18/10

corrigido waypoints de Astar serem mandados invertidos (do fim pro começo) e sem o nó final.
LA_ros.m cria mensagem UInt32MultiArray para enviar waypoints, drone_wp.py recebe estes wp.
matriz de 3 dimensoes criada para waypoints: trajetoria (mov carga ou descarga), waypoints que compoem a traj, e valores i e j no mapa do waypoint
no matlab: array de celulas, cada celula contem matriz.
no python: numpy array de 3 dimensoes. (maior trajetoria define tamanho da segunda dimensao, outras trajs sao completadas com 0's)

----------------------------------------------------------
22/10

fazendo bias_roll3 em drone_wp.py
>> terminar bias_roll3
>> remover waypoints colineares

grid desnecessario para single drone sem objeto (A* poderia escolher caminho direto para zonas), 
porem necessario (facilitador) para multidrone

--------------------------------------------------------
23/10

checado o sign em bias_roll3 para ver se movimento de correção está correto
>> verificar se bias_roll3 está completo (acho q sim)

---------------------------------------------------------
24/10

terminado reduçao de waypoints por colinearidade. ajustado xteta (custo de rotaçao) de 0 para 0.1,
pois estao havendo rotaçoes desnecessarias (ver rotaçoes_desnecessarias.png)
mesmo com xteta=0.1, haviam algumas rotaçoes desnecessarias, pois no A*
os f's (f=g+h) que eram pra ser iguais, estavam dando diferença na 15a casa decimal, e tambem
f's iguais nao tinham desempate (incluido desempate para priorizar quem tem menor g)
com isso, (AINDA NAO!) resolvido problema de ter rotaçoes adicionais desnecessarias (geralmente proximas ao ponto final) (ver fig rot_desness2.png)
essa alteraçao fez o LA ficar bem mais lento (soluçao foi round nos f's)
(not needed) ver se floor deixa menos lento que round 
(x) checar tempo total do treinamento e tempo por iteraçao
(x) voltar para A* antigo e ver tempos
(not needed) checar tempo com round 1e7

>>>>> LA lento com novo A* (round de 10 casas):
tempo total: 113.939
n_iter: 487
tempo/iter: 0.23396

tempo total: 216.209
n_iter: 1001
tempo/iter: 0.21599

>>>>> com round de 6 casas: msm coisa
tempo total: 75.17
n_iter: 267
tempo/iter: 0.28154

>>>>> com round alternativo de 6 casas (usando *1e6/1e6)
tempo total: 17.938
n_iter: 171
tempo/iter: 0.1049

tempo total: 18.083
n_iter: 214
tempo/iter: 0.0845

>>>>> sem os rounds:
tempo total: 23.548
n_iter: 283
tempo/iter: 0.083208

>> Salvar distancias de A* ja realizados para evitar A* "iguais"? (serve apenas para single drone, pois obstaculos estaticos)
>> o desempate de f usando menor g nao resolve todas as rotaçoes a mais, o real problema é
a expansao do ultimo nó utilizar rotaçao, pois esta nao é considerada como um problema pois
o A* acaba naquele momento.
--------------------------------------------------------
25/10

ajustado A*: se a primeira rota encontrada tem ultimo movimento com rotaçao, nao termina ainda
e encontra uma segunda rota, compara as duas (com isso, evita-se a possivel rotaçao extra no final)
brecha: se só existir um caminho para o goal, a procura pela segunda rota entra em loop infinito.
removido desempate de f checando g

(x) remover brecha do A* (LA ficou lento, mtos if elses, arrumar estrutura)
(x) terminar drone_wp.py: drone realiza movimentos para completar waypoints
---------------------------------------------------------
28/10

alterada estrutura dos if's para tratar segunda rota, porem LA continua mto mais lento (iteraçoes maiores ficam mais lentas)
corrigida lentidao, problema era Astar desenhando a cada iteraçao.

-----------------------------------------------------------
29/10

terminado drone_wp.py
>> recalibrar camera e começar testes de voo
(x) organizar codigos e problemas/restriçoes ja resolvidos/a resolver
(x) desenhar obj nas zonas de descarga como num.obj.atual/demanda (ex: 0/3)
-----------------------------------------------------------
30/10

organizando codigos e problemas/restriçoes ja resolvidos/a resolver: testando capac de carga em LA_traj8.m
arrumando rota2.m para executar casos de capac.carga>1

-------------------------------------------------------------
31/10

arrumado rota2.m e LA_traj8.m sobre capac carga:
LA_traj8 modificado na parte de carga, agora para 5 objetos matriz p_carga possui 5 linhas e nao 4, e ja inclui as restriçoes de carga para ultimos movimentos
(se existem apenas 3 objetos restantes, nao considerar pegar mais que isso)
salvo backup do LA_traj8 antigo.

------------------------------------------------------------
01/11

testado cam_pos4.py (sem ROS), localização parece estar ok.

-----------------------------------------------------------
04/11

lendo parte de multidrone da tese do sergio
multidrone do sergio: A* replanejado a cada pequeno step de tempo/movimento
resolução de conflitos: utiliza diferente velocidades e pontos de parada para resolver


-----------------------------------------------------------
05/11

helices novas: ok
teste de execução de wp: testado apenas wp logo a frente: ok. falta wp em diagonal, lados e atras
Sergio usou um algoritmo de learning BASEADO no LRI (para controlador) e LRP (para montagem), e não os algoritmos em si
uma das alterações que eu percebi foi a mudança de p = p + nR(1-p) para p = p + nRp (baixas probs agr sobem lentamente, e altas probs sobem rapido)(eu utilizo o msm metodo dele)

reuniao:
>> mencionar que a heuristica foi trocada
>> conflito em multi-drone: usar drones em alturas diferentes? excluiria conflitos em trajetorias, manteria apenas conflitos em carga/descarga
>> multidrone do sergio: A* replanejado a cada pequeno step de tempo/movimento
feito:
>> desenhado indicador de demanda em cada zona de descarga (ex: 0/3)
>> organizaçao dos codigos/word quanto às aplicações (mostrar word)
>> teste de execução de wp: testado wp logo a frente do drone: ok
a fazer:
>> execução dos wp em diagonal, lado, atras

----------------------------------------------------------------
06/11

testado execuçao wp para frente e lado
começando multidrone em LA_traj_multi.m e Astar_multi.m

----------------------------------------------------------------
11/11

testado execuçao wp na diagonal (ok), usando angulo_round apenas para definir se usará controleY ou X ou diag, o movimento em diag usa angulo normal calculado
dificil execução de bias_roll3, correção de posição ruim

----------------------------------------------------------------
12/11

modificado Astar_multi para dar apenas 1 passo no trajeto encontrado.
fazendo LA_traj_multi.m

----------------------------------------------------------------
17/11

fazendo modulação de cada funçao em LA_multi:
uma funçao que define qnt de carga, outra que define a carga a ser escolhida, etc
assim, cada drone chama a funçao quando precisar, sem interferir nas açoes do outro.

-------------------------------------------------------------
18/11

arrumar:
(x) apos um dos transp pegar ultimo objeto, o outro tenta pegar o ultimo objeto denovo (checar prob_sum1 nos ultimos obj)
Index exceeds the number of array elements (5).
Error in LA_trajetoria_multi>decidir_carga (line
475)  pos=obj(mov1(n,k2(n))); % nova posição

(x) A* do ponto 3,2 para 1,10

--------------------------------------------------------------
19/11

LA_multi já treinando
possibilidade de travamento (Astar_multi) caso dois transps estejam lado a lado e um quer ir para
a posiçao do outro.

(x) verificar condição para convergencia, ja que os tranps nao usam todos os intantes de carga

>> criar raio de segurança para transps nao ficarem proximos

reuniao:
>> Ler sobre TCAS (Traffic collision avoidance system)
(x) ver tese sergio e Sastry para ver como convergir probs para multi-drone
>> ideia para convergir: convergir primeiramente o primeiro movimento de cada transp, dps o segundo...
(aprendizado por partes)

Learning Automata: aprende sequencia de açoes dadas certas restrições
--------------------------------------------------------------
25/11

LA_multi funcionando, condiçao de convergencia: numero de automatos convergidos == numero de objetos
Sergio: treina todas as ações de todos os drones simultaneamente (igual eu estou fazendo)
Sergio: numero de açoes de cada drone já predefinidas antes do treinamento (6obj, 2drones: 3 pra cada)
meu LA: nao é predefinido, eles aprendem quantas peças pegar (minimo de 1 peça por drone)

usar apenas reforço positivo ou ref negativo fraco: treina mais rapido, porem resultados piores

arrumado problemas de probabilidades nos casos de mais de 1obj por zona de carga: agr funciona.

(x) arrumar problema quando demanda diferente do padrao

(nao me parece ser util) fazer LA_multi2 com ideia do Cairo: treinar/convergir uma açao por vez
----------------------------------------------------------------
26/11

demanda inf e 1obj por zona carga: funcionando
demanda: agr funcionando
mais de 1obj por zona carga: funcionando

(x) criterio de parada: alem de prob_conv, esperar reforço == 0?(ou dist_media==dist) (pode melhorar resultado)
(x) fazer rota_multi
>> ler Sastry: ver sobre convergencia para multi_transportadores
>> separar reforço por transportador? (dois reforços, calculados para a distancia de cada transportador)
(x) remover transp considerar o outro como obstaculo,
>> e fazer gerenciamento de conflito apenas em rota_multi (na execução do planejamento)
(x) fazer log de A*,
(x) analisar tempo por iteraçao com e sem log

---------------------------------------------------------------
27/11

terminado rota_multi.m, que executa plajemanento de LA_traj_multi.m
>> fazer gerenciamento de conflito

reuniao:
Sergio: treina todas as ações de todos os drones simultaneamente (igual eu estou fazendo)
Sergio: numero de açoes de cada drone já predefinidas antes do treinamento (6obj, 2drones: 3 pra cada)
meu LA: nao é predefinido, eles aprendem quantas peças pegar (minimo de 1 peça por drone)
>> funcionando demanda, mais de 1 obj por zona carga, e os 2 juntos
>> treinamento: converge numero de linhas = numero de objetos necessarios para tarefa
>> removido transp considerar o outro como obstaculo e fazer gerenciamento de conflito apenas na execução do planejamento
>> feito log de A*, analisando tempo por iteraçao com e sem log
>> execuçao do planejamento em rota_multi.m
fazer agr:
>> TCAS (somente dizer que a altura mudou?) e/ou raio de segurança
>> melhorar simulaçao (desenhar drone e fazer movimentos suaves durante o tempo: drone se movendo suavemente)
>> incluir restriçoes (carga, ordem, zona)
>> execução single-drone: melhorar movimentos para chegar em wp (arrumar bias_roll3)
>> hashmap para log de A*

---------------------------------------------------------------
29/11

cam_videosaver.py (sem ros) funcionando mais ou menos
alterar bias_roll3, fazer oq cairo disse: transformar coord global pra local, inves do contrario
drone agr tende mto pra direita? (quase reto: pitch 15, roll -14)
com -14, faz arco (começa indo pra esquerda, dps pra direita), com -15 vai indo pra esquerda
tentar denovo fazer um bias que altera valor de roll de acordo com mambo_speed_x/y

---------------------------------------------------------------
03/12

(x) terminar objeto de fibra de carbono
testando movimentos do drone, e formas de bias_roll
>> testar mais vezes pitch 10 (lento), pra ver o efeito do bias
(x) testar movimentos de roll, ver se consegue lento
--------------------------------------------------------------
04/12

alça do objeto de papel ou de estanho parece bom, papel é mais leve
feita com papel, drone conseguiu carregar bem o objeto.
movimentos de roll usando base -14 e r/l = 10/-10: movimentos suaves, sem oscilação no eixo de mov do pitch
base -10, roll 12/-8, pitch 15/-15:
roll mais rapido, bias para trás um pouco,
pitch fraco para tras, bias para esquerda

---------------------------------------------------------------
07/12

rand=1,demanda=2/2/2/2, qtd_obj=3/3/3/3/3: mostra conflito sendo gerenciado perto do final
arrumando problemas de obstaculo quando raio>=2 e cobre o ponto de destino do A*
fazendo bias_roll continuo, utilizando velocidade para boostar o roll
>> ajustar fino X e Y apos controleX ou Y ou diag
(x) resolver problema no seed 4 (drones pegam a mesma peça (segunda peça 4: peça 11))

-----------------------------------------------------------------
10/12

seed que gera o gerenciamento de conflito perto da zona 4: seed 5
>> como resolver prob acima: cond2 verificar apenas peças escolhidas por prob1/cond1, e nao toda prob2
(nem precisou fazer)
>> testar nao usar ROS para enviar localização da camera, pois isso eh feito por TCP/IP oq gera atraso

----------------------------------------------------------------
21/01

resolvido problema da seed4: nao estava limpando mov1 a cada iteraçao
>> ler artigo q o cairo mandou e procurar outros sobre waypoints, localizaçao e controle com drones
>> localizaçao sem ROS
>> localizaçao por tags aruco

----------------------------------------------------------------
22/01

ajustado PlotMap e rota_multi para incluir simulaçao 3D
>> fazer ação de carga e descarga
>> fazer TCAS por mudança de plano de altura

----------------------------------------------------------------
27/01

casos mencionados no artigo do Sidney:
>> (UAV attack mission) obstaculos (moveis ou nao) nao sao conhecidos a priori, e são adicionados
apos UAV chegar em certos pontos.
>> (elderly care mission) obstaculos são conhecidos a priori
em ambos, guiagem de posição inicial para final, com objetos estáticos e móveis.
os obstaculos são representados por equações matematicas que influenciam na função custo; similarmente,
para o A*, os obstaculos sao pontos no grid que influenciam a expansao dos nós (trajetoria estimada).
nesse artigo, usou-se tambem a abordagem hibrida, onde o WP era definido pelo A*, mas o obstacle avoidance
foi feito com o R-MPC. No meu caso, para fazer obs avoid, usa-se A* a cada timestep (como também é sugerido
no artigo).
----------------------------------------------------------------
28/01

lendo segundo artigo. Keyword: Task Assignment problem (AP)
abordagem com genetic algorithm para resolver variaçao de AP onde agentes no mesmo time aumentam seu valor
de contribuiçao na task. interessante a ser copiado: avaliação de accuracy, stability, scalability,
robustness, impacto do criterio de parada.
>> ver hungarian method

---------------------------------------------------------------
29/01

lendo terceiro artigo

>> PSO, Bit-Star, Q learning, Taxi cab, Dijkstra
>> dimensionamento de bobina
>> ver hungarian method
>> artigos sobre waypoints, localizaçao e controle com drones

>> localizaçao sem ROS
>> localizaçao por tags aruco
>> fazer ação de carga e descarga

--------------------------------------------------
30/01

testando multidrone com 3 transps
erro em seed1: drones 2 e 3 aprendem a deixar segundo obj3 (obj8), mas nao o primeiro (que ta sendo
pego pelo transp2 nas ultimas iter).

--------------------------------------------------
31/01

3 transps funcionando, problema da seed1 era 2 objetos irem carregar na msm zona, obj_qtd_temp reduzia 2x
antes de os transps decidirem descarga, ai o obj2 ficava errado (os 2 transps pegavam o segundo obj),
correçao: obj2 saiu da descarga p/ carga.
(x) checar outras seeds
(x) comparar dist_total para 1,2,3 transps
>> colocar restriçoes
(x) testar 4 transps

---------------------------------------------------
03/02

procurando sobre dimensionamento de bobinas planares, nao achei algo direto
aplicando calculo de corrente do Maglev, deu corrente bem alta, seria inviavel para o drone, alem do peso da bobina (e uma bobina menor precisaria de mais corrente)

---------------------------------------------------
04/02

arrumado cores para transps: azul, verde, vermelho, azul, ...

mapa 17x29 obj=[3,3,3,3,3] dem=[2,2,2,2], 3 transps
seed1 dist: 228,3797/228,3797
seed2 dist: 253,0807/247,7229
seed3 dist: 240,7939/240,7939
seed4 dist: 243,6249/243,6249
seed5 dist: 254,8356/250,0513
seed6 dist: 230,4655/219,8234
seed7 dist: 249,2939/247,5660
seed8 dist: 246,7376/245,3234
seed9 dist: 256,5219/240,1076 prob na execuçao: treinamento faz obj4 ser pego por drone 1 dps 2, mas execução faz ordem ser 2-1 por causa do gerenciamento de conflito
seed10 dist: 221,5513/221,5513

--------------------------------------------------
05/02

arrumado prob da seed9: decisao de descarga nao verifica exatamente obj2 que foi treinado, e sim obj2 que o transp sabe descarregar
(Ex: old: transp sabe descarregar obj2 = 11 em [3,3,3,3,3] (segundo obj4), new: transp checa quais dos obj4 (10/11/12) ele sabe descarregar)

testado 4 transps
seed10: 264,3356/264,3356

---------------------------------------------------
07/02

feito açao de carga e descarga
(x) testar descarga

----------------------------------------------------
10/02

testado descarga.
>> testar diferentes mapas/demanda/obj_qtd/num_transp
>> procurar se existe calibraçao para o mambo -> calibrar manualmente (flightpromini) antes do takeoff

-----------------------------------------------------
11/02

reuniao:
>> feito ação de carga e descarga na execução (no treinamento nao teria impacto)
>> feito plot 3D para demonstrar variação de altura dos transportadores
>> testado multidrone para 3 e 4 transps.
o que fazer:
>> restrições para multidrone
>> comparaçao entre diferentes num_transp/tamanho do mapa/neta/dist-dist_min(atingiu o minimo?)/apenas reforço positivo
>> execução na prática

transp=2, neta=0.11, map19x27, xteta=1
seed1: 238,3381/idem (105 steps)
seed2: 237,6934/idem (96 steps)
seed3: 249,0782/240,5929 (101 steps)
(neta=0.1: 250,0244/249,3381)
(neta=0.09: 242,7229/241,8944)
(neta=0.08: 239,3087/idem)
(neta=0,05: 244,0244/239,8823)
seed4: 240,6518/232,5513, (96 steps)
(neta=0.1: 244,5513/235,5513, 104 steps)
(neta=0.09: 238,7939/idem, 101 steps)

transp=1, neta=0.11, map19x27, xteta=1
seed1: 231,6371/223,7670 (173 steps)


>> ajustar rota_multi/Astar_multi para funcionar com 1 transp
----------------------------------------------------
12/02

fazendo restrição de capacidade de carga dos transps.

----------------------------------------------------
13/02

reuniao:
>> montar arvore mostrando aplicações e restrições (papel na gaveta)

>> terminar restriçoes (carga-R1, ordem-R2, zona-R3) e modificar R3 para especificar qtd de cada tipo de obj desejado.

-----------------------------------------------------
14/02

trocando caso de carga>1 para poder descarregar em locais diferentes, e nao todas em um msm lugar
(faz mais sentido para aplicações praticas, e evita problemas com demanda -> ex: drone2 escolhe pegar 2 peças,
pois existe zona com 2 espaços livres, porem drone1 apos isso descarrega uma peça na unica zona que caberia 2,
agr todas as zonas so cabe 1, e drone2 nao consegue mais escolher descarga)

-----------------------------------------------------
17/02

Problema de resgate tambem pode ter restriçao de ordem (paciente em estado mais grave que outros)
(x) feita arvores de aplicações e restriçoes no draw.io

-----------------------------------------------------
18/02

arrumando restrição de carga
tecnica da piramide da camera: ortorretificação (tbm deve ser interpolação)

------------------------------------------------------
19/02

(x) finalizado restrição de carga para treinamento e execução
testada seed 2
>> melhorar Astar para caso onde no_final está obstruido (atualmente o transp espera de muito longe)

------------------------------------------------------
20/02

testando outras seeds para restrição de carga
prob na execução da seed1

------------------------------------------------------
21/02

reuniao: tipos preferidos de arvore: 4.1 e 5 (usar as duas), novo R1: número e capacidade dos transportadores.
como mostrar gerenciamento de conflito: curvas no plano xy com pontos de tempo (olhar folha)

arrumada execução da seed1
testado da seed1 até a 4

-----------------------------------------------------
27/02

testadas seeds de 1 a 9

fazendo restrição de ordem e tipo
dois possiveis tipos de restrição de ordem:
-- ordem global, onde a primeira/segunda/... peça a ser (des)carregada eh especificada.
-- ordem por zona de descarga, onde cada zona deseja uma ordem especifica de peças
(ja incluiria restrição de tipo)

ordem global daria problema para treinamento dos transps, tanto ordem de carga ou descarga, 
pois outros transps nao poderiam pegar outras peças que estivessem perto deles.
esta restrição nao garantiria que o obj com prioridade seria escolhido pelo transp mais proximo
(precisaria de uma tabela de distancias)
----------------------------------------------------
03/03

restrição de ordem funcionando, testar outras seeds (testada a 0)

----------------------------------------------------
04/03

seed4 com problema: terceiro mov1 de um dos transps é desaprendido, fazendo treinamento convergir com movs 1, 2 e 4 (e transp1 com 1,2 e 3, sendo ele o resp por pegar 4 obj)
seed5 nao converge com 10k iteraçoes (prob2(1,:,2) chega a 0.95)

----------------------------------------------------
05/03

execução da seed10 nao funciona para raio=2 (raio=1 funciona), pois 2 transps se travam no canto do mapa
restrição de ordem global pode ser feita checando se um dos n transps pegaram a peça na ordem desejada. ex: se um certo obj quer ser o primeiro a ser pegado, um dos tres transps deve
ter como primeira carga este obj.
-- ordem por transp: cada transp tem uma ordem de peças a carregar. muito "facil", nao parece ser muito util.

----------------------------------------------------
06/03

feita restrição de tipo_qtd, testando seeds. seeds de 0 a 10: todas ok
feita restrição de ordem_c (ordem global/das zonas de carga), not yet implemented

----------------------------------------------------
11/03

drone_teste.py testado (1x) com vel=10: bem lento, alto bias para direita qnd indo para tras
LA_multi testado (1x) com apenas 1 transp em mapa simples.

-----------------------------------------------------
13/03

drone_teste.py: vel20 sem bias: roll para direita mais forte. pitch com inclinação para direita
(inicialmente pouco, depois aumenta)

reuniao:
>> terminada simulaçao (falta ordem_c, e realizar diversos testes em varias configs)
>> falta estruturar waypoints a serem passados (incluindo quando realizar carga/descarga)
>> testando drone com tolerancia de wp = 4cm: ok, melhorando.
>> tentar realizar teste efetuando açao de carga e descarga

pos-reuniao:
>> testar/comparar LRP com LRI
>> olhar PLA/GLA
>> analise de escalabilidade, usando uma variavel para relacionar tudo no codigo:
n zonas carga, n/2 zonas descarga, n/3 transps, etc. escalar n e ver tempo/resultado.
>> na arvore de problemas, trocar para nós serem problemas, e setas serem restrições.

-----------------------------------------------------
20/03

(x) fazer nova arvore, trocando nos por setas
>> arrumar ordem_c e waypoints
>> voo do drone

------------------------------------------------------
27/03

reuniao:
>> fiz a arvore das aplicações e restrições colocando os nós como casos e as setas como restriçoes
>> fazendo simulação no Gazebo com Eugenio

>> finalizar ordem_c
>> finalizar waypoints e passar para eug_sim

------------------------------------------------------
31/03

waypoints arrumados em rota_multi (nao precisa mais de reduçao de wp, pois o controlador PurePursuit age
melhor com varios wp proximos)
waypoint tem um terceiro indice, apos o x e y, indicando se eh wp comum (0), wp de carga (1) ou descarga (2)
pegar imagem do mapa preto e branco e criar matriz.
>> finalizar ordem_c
>> testar/comparar LRP com LRI
>> olhar PLA/GLA
>> analise de escalabilidade, usando uma variavel para relacionar tudo no codigo:
n zonas carga, n/2 zonas descarga, n/3 transps, etc. escalar n e ver tempo/resultado.

---------------------------------------------------------
02/04

Astar ficou mto lento com mapas grandes, mapa reduzido para 160x160
treinamento com 3 objs, 2 zonas e 3 transps nesse mapa:
tempo total: 549.748
n_iter: 141
tempo/iter: 3.8989

tempo total: 154.396
n_iter: 106
tempo/iter: 1.4566

gazebo funfando, pega wp gerado por rota_multi_sim, que eh gerado por LA_traj_multi_sim.
>> alterar movimento em LA e rota para nao ser so 1grid por Astar, e sim os Astar de cada drone diz
quantos movs vao ser necessarios (ex: 300/400/450) e executa-se num de passos = minimo deles.

-----------------------------------------------------------
03/04

reuniao:
sobre o controlador purepursuit do matlab: modelo cinematico, modelo de guiagem
é um 'controlador' que gera referencias para outro controlador (o de baixo nivel do gazebo/ros)

----------------------------------------------------------
07/04

artigo 1 sobre gerenciamento de conflito:
usa waypoints de 4 dimensoes (inclue tempo) (ele usa modelo, nao seria interessante pra mim pois 
treinamento nao inclui modelo, logo nao adianta estipular tempo dos wp), matriz de distancia interdrones (por pares),
sequential quadratic programming(SQP) method (35), piecewise-linear trajectory parameterization, 
menciona tecnicas como GA, controle otimo, potencial fields, differencial game theory.

-----------------------------------------------------------
08/04

Criado Eug_sim2.m, para fazer o gerenciamento de conflito usando Astar e gerar WP's on the fly

-----------------------------------------------------------
09/04

(x) fazer pouso suave parar drones
(x) testar colisao
(x) fazer descida para processo de carga

-----------------------------------------------------------
13/04

feito pouso suave.
feito descida/subida para loading.
gerenc conflito ainda dando problema.
Nao usar purepursuit no gerenc conf, pois nao funfa bem, usar yaw e pitch separado.

------------------------------------------------------------
16/04

arrumado conflito (falta conflitos em zonas de carga/descarga)
em fim de conflito, raio de conflito diminuido por algumas iterações para evitar alguns problemas.

-------------------------------------------------------------
18/04

save_data.py(ros/servidor) e cam_videosaver(nao-ros/laptop) para gravar dados e video dos testes.
teste pratico: gravado dois testes, teste 2 foi bom, executou 2 waypoints (tol 5.5cm)
(x) plotar dados do txt para ver

-------------------------------------------------------------
20/04

feito plot para mostrar xy dos testes praticos, usando txt de dados
tbm faz plot de altura do drone por "tempo" (tempo = numero de posiçoes salvas)
>> salvar comandos dados para cada posição, checar algums movs que tiveram yaw mto diferente
>> alterar movimento em LA e rota para nao ser so 1grid por Astar, e sim os Astar de cada drone diz
quantos movs vao ser necessarios (ex: 300/400/450) e executa-se num de passos = minimo deles.
>> simulaçao: teleporte do drone de cor
>> conflito para zonas: tentar apenas mudar prioridade
>> fazer mapa simetrico sem paredes onde 4 transps vao para 4 objs juntos no meio

-------------------------------------------------------------
